# -*- coding: utf-8 -*-
"""Untitled28.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q856kGMBB_ImadZ7GJozp3qKTDX2orFS

#Feature Engineering,

Handelling Missing Values

Imbalance Dataset

Outlier Detection

Encoding - Lable - OHE

#handeling outliers
"""

#5 number summery
# min, max, median , Q1, Q2(median), Q3, IQR

import numpy as np

marks = [45,32,56,75,89,54,32,89,90,87,67,54,45,98,99,67,74]
min, Q1, median, Q3, max = np.quantile(marks,[0,0.25,0.50,0.75,1.0])

min, Q1, median, Q3, max

IQR = Q3 - Q1

IQR

lower_fence=Q1-1.5*(IQR)
higher_fence=Q3+1.5*(IQR)

lower_fence , higher_fence

marks

import seaborn as sns

sns.boxplot(marks)

new_marks=[-100,-200,45,32,56,75,89,54,32,89,90,87,67,54,45,98,99,67,74,150,170,180]

sns.boxplot(new_marks)

"""# Data Encoding

1 - Nominal/OHE Encoding
2 - Label and Ordinal Encoding
3 - Target Guided Ordinal Encoding


Nominal/OHE Encoding
One hot encoding, also known as nominal encoding, is a technique used to represent categorical data as numerical data, which is more suitable for machine learning algorithms. In this technique, each category is represented as a binary vector where each bit corresponds to a unique category. For example, if we have a categorical variable "color" with three possible values (red, green, blue), we can represent it using one hot encoding as follows:

Red: [1, 0, 0]
Green: [0, 1, 0]
Blue: [0, 0, 1]
"""

import pandas as pd
from sklearn.preprocessing import OneHotEncoder

df = pd.DataFrame ({'color' : ['red', 'green', 'blue', 'red', 'blue', 'green', 'red']})

df

encoder = OneHotEncoder()

encoded = encoder.fit_transform(df[['color']]).toarray()

encoder_df = pd.DataFrame(encoded, columns = encoder.get_feature_names_out())

encoder_df

"""#ordinal - lable encoding"""

tips =sns.load_dataset('tips')

tips

tips.info()

from sklearn.preprocessing import LabelEncoder

le = LabelEncoder()

cat_columns = ['sex', 'smoker', 'day', 'time']

for columns in cat_columns:
  tips[columns] = le.fit_transform(tips[columns])

tips.head()

"""#Data Wrangling - handeling missing values, cleaning the datasets, encoding and feature engg. creating new featuers"""

titanic = sns.load_dataset('titanic')

titanic.head()

#handelling missing values

titanic.info()

titanic.isnull().sum()

#handeliilng missing values

#fill the missing values in age, as we see age is numerical data. so we replace with median

titanic['age'] = titanic['age'].fillna(titanic['age'].median())

#fill missing values in embarked. we know embarked is categorical feature so place them with mdoe

titanic['embarked'] = titanic['embarked'].fillna(titanic['embarked'].mode()[0])

titanic['embark_town'] = titanic['embark_town'].fillna(titanic["embark_town"].mode()[0])

#drop column with too many missing values

#examples - deck contain 688 missing values. so drop

titanic = titanic.drop(columns = ['deck'])

titanic.head()

titanic.info()

# renaming columns for easy to understand

titanic = titanic.rename(columns= {'embark_town' : 'Tembarked', 'pclass' :'passenger_class'})

titanic.head()

#encoding

titanic['sex'] = titanic['sex'].map({'male':1, 'female': 0})

titanic.head()

titanic['Tembarked'].unique()

embark_order = {'Southampton' :0, 'Cherbourg':1, 'Queenstown':2}
titanic['Tembarked'] = titanic['Tembarked'].map(embark_order)

titanic.head()

#new columns
titanic['family_size'] = titanic['sibsp'] + titanic['parch'] +1  #1 for self

titanic.head()

