# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DR0ftTx3JtBn2e_4ESWexjTIzI6KuDKU
"""

def cumulative_sum (numbers):
  cumulative_list = [ ]
  total = 0

  for num in numbers:
    total = total + num
    cumulative_list.append(total)

  return cumulative_sum

numbers = [ 1,2,3,4,5,6]
print(cumulative_sum(numbers))

def cumulative_sum(numbers):
    cumulative_list = []
    total = 0
    for num in numbers:
        total += num
        cumulative_list.append(total)
    return cumulative_list

# Example usage
numbers = [1, 2, 3, 4]
print(cumulative_sum(numbers))  # This will print the cumulative sum list

"""#OOP
In Python, classes and objects are core concepts of Object-Oriented Programming (OOP), which helps organize code and manage complexity by grouping data and functionality together. Let's dive into each concept and its components with detailed examples.

#1. Classes
A class is like a blueprint or a template for creating objects. It defines a set of attributes (data) and methods (functions) that the objects created from the class will have. Classes allow you to define custom data structures that can store various information and provide ways to interact with it.

Creating a Class
In Python, a class is created using the class keyword followed by the class name (usually in PascalCase).
"""

class Person:
  species = "Homo Sapiens"


  #initialise method ( constructor)
  def __init__ (self, name, age):

    self.name = name #instance variable (attributes )
    self.age = age


  def display_info(self):
    print(f"Name:{self.name}, Age: {self.age}")

"""#2. Objects
An object is an instance of a class. When a class is defined, only the blueprint is created. To use the blueprint, we create objects, which contain actual values.
"""

person1 = Person("Dipali", 23)
person2 = Person("Harsh", 21)

person1.display_info()

person2.display_info()

"""#3. __init__ Method (Constructor)
The __init__ method is automatically called when an object is created. It initializes the object’s attributes.

self is a reference to the current instance, allowing access to the instance’s attributes and methods.
Instance variables are defined within __init__ and prefixed with self.

def __init__(self, name, age):

    self.name = name
    
    self.age = age

#4. Encapsulation

Encapsulation restricts direct access to some of an object’s components, typically using "private" or "protected" attributes. This helps to keep data safe from outside interference and misuse.

In Python, prefixing an attribute with an underscore (_) signals that it’s intended for internal use only, while prefixing with two underscores (__) invokes name mangling to make it harder to access from outside the class.
"""

class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # Private attribute

    def deposit(self, amount):
        self.__balance += amount

    def withdraw(self, amount):
        if amount <= self.__balance:
            self.__balance -= amount
        else:
            print("Insufficient funds")

    def get_balance(self):
        return self.__balance

account = BankAccount(1000)

account.deposit(500)

print(account.get_balance())

account.withdraw(200)

print(account.get_balance())

"""#5. Inheritance

Inheritance allows a class to inherit attributes and methods from another class. It helps create a hierarchy of classes and promotes code reusability.
"""

#parent class

class Vehicle:

  def __init__ (self, brand, model):
    self.brand = brand   #instance create
    self.model = model

  def start(self):
    print(f"{self.brand} {self.model} is starting")


#child class

class Car(Vehicle):
  def __init__ (self, brand, model, seats):
    super().__init__(brand, model) #call parent counstructor
    self.seats = seats

  def honk(self):
    print("Beep beep!")


my_car = Car("Toyota", "Fortuner", 7)

my_car.start()
my_car.honk()

import keyword

print(keyword.kwlist)

"""Introduction to Python

Installing Python and setting up the environment
Writing and running your first Python program
Python syntax and basic operations
Using Jupyter Notebook and other IDEs (e.g., VS Code, PyCharm)
Data Types and Variables

Basic data types: integers, floats, strings, and booleans
Variables and assignment
Type conversion (casting)
Operators

Arithmetic operators (+, -, *, /, %)
Comparison operators (==, !=, >, <, >=, <=)
Logical operators (and, or, not)
Assignment operators (+=, -=, *=, etc.)
Control Structures

Conditional statements (if, elif, else)
Loops (for and while loops)
Break, continue, and pass statements
Data Structures

Lists: creating, indexing, slicing, and methods
Tuples: characteristics and uses
Dictionaries: key-value pairs, accessing values, and dictionary methods
Sets: unique elements, set operations
Functions

Defining functions and using return
Parameters and arguments
Lambda functions, MAP, FILTER

Modules and Packages

Importing modules (math, datetime, etc.)
Creating and using custom modules
Installing packages using pip (e.g., numpy, pandas)

File Handling

Reading and writing files (text and binary)
File handling methods (open, read, write, close)
Exception handling in file operations
Error Handling and Exceptions
Common exceptions in Python (e.g., ValueError, TypeError, IndexError)
Custom exceptions


Object-Oriented Programming (OOP)

Classes and objects
Attributes and methods
Inheritance, encapsulation

self and __init__ method

Libraries and Frameworks for Data Analysis

Introduction to numpy and pandas for data manipulation
Data visualization basics with matplotlib and seaborn

#NUMPY
NumPy (Numerical Python) is a powerful library in Python that provides support for large, multi-dimensional arrays and matrices, as well as a wide variety of mathematical functions to operate on these arrays. NumPy is widely used in data science, machine learning, and scientific computing.


Installing NumPy
If you don’t have NumPy installed, you can do so using pip:

bash
Copy code
pip install numpy

import numpy as np
"""

import numpy as np

list = [1, 2,3,4]

type(list)

arr = np.array([1,2,3,4])  #one dimentional arrray

arr

list

arr = np.array(list)

arr

list1 = [1,2,3,4]
list2 = [5,6,7,81]

arr2 = np.array([list1, list2])

arr2

arr3 = np.array([[9,8,7,4], [78,45,98,65]])

arr3

zeros = np.zeros((2,3))  #arrays of zeros

zeros

ones = np.ones((3,3))

ones

#identity matrix

identity = np.eye(4)

identity

#FULL MATRIX

full = np.full((2,2), 7)

full

random_arr = np.random.random ((2,3))
random_arr

np.random.rand(3,2)

#array with mean = 0, SD = 1

np.random.randn(2,2)

np.random.randint(1 ,10 , size =7)

"""#arange"""

np.arange(0 , 10)

np.arange(0 , 10, 2) #3rd element is for stepsize

"""#linspaces"""

np.linspace(0, 1, 5)

np.linspace(1, 255, 100)

